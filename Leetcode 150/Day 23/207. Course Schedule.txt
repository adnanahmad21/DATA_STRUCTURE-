There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
 

Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
All the pairs prerequisites[i] are unique.
 




solution 


approach 1 :: using dfs


class Solution {
    boolean dfs(List<List<Integer>> adj,int rec[], boolean visited[],int u)
    {
 visited[u]=true;
 rec[u]=-1;
        for(int v:adj.get(u))
        {
            if(!visited[v] &&  dfs(adj,rec,visited,v))
            {
               return true;
            }
            else if(rec[v]==-1) return true;
        }
        rec[u]=0;
        return false;
    }
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        
        List<List<Integer>> adj=new ArrayList<>();
        for(int i=0;i<numCourses;i++) adj.add(new ArrayList<>());
        for(int arr[]:prerequisites)
        {
            adj.get(arr[1]).add(arr[0]);
        }
        boolean visited[]=new boolean[numCourses];
        int rec[]=new int[numCourses];
//  Arrays.fill(rec,-1);
     for(int i=0;i<numCourses;i++)
     {
        if(!visited[i] && dfs(adj,rec,visited,i)) return false;
     }
     return true;
        
    }
}






approach 2::

 using kahns algorithm


class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
       List<List<Integer>> adj=new ArrayList<>(); 
       for(int i=0;i<numCourses;i++) adj.add(new ArrayList<>());
       for(int arr[]: prerequisites)
       {
        adj.get(arr[1]).add(arr[0]);
       }
       int degree[]=new int[numCourses];
       for(int i=0;i<numCourses;i++){
        for(int v: adj.get(i)){
            degree[v]++;
        }
       }
       Queue<Integer> q=new ArrayDeque<>();
       for(int i=0;i<numCourses;i++)
        {
            if(degree[i]==0) q.add(i);
        }
       int cnt=0;
       while(q.size()>0)
       {
        int u=q.poll();
        cnt++;
        for(int v: adj.get(u))
        {
            degree[v]--;
            if(degree[v]==0) q.add(v);
        }
       }
       return (cnt==numCourses);
    }
}