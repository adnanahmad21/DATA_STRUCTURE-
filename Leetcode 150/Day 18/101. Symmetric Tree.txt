Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

 

Example 1:


Input: root = [1,2,2,3,4,4,3]
Output: true
Example 2:


Input: root = [1,2,2,null,3,null,3]
Output: false
 

Constraints:

The number of nodes in the tree is in the range [1, 1000].
-100 <= Node.val <= 100
 

solution:::


class Solution {
   boolean solve(TreeNode root1,TreeNode root2)
   {
     if((root1==null && root2==null) ) return true;
     if((root1==null && root2!=null) || (root2==null && root1!=null)) return false;
     if(root1.val!=root2.val) return false;
     return solve(root1.left,root2.left) &&solve(root1.right,root2.right); 
   }
    void invertTree(TreeNode root)
    {
        if(root==null || (root.left==null && root.right==null)) return;
        invertTree(root.left);
        invertTree(root.right);
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
    }
    public boolean isSymmetric(TreeNode root) {
         if(root==null || (root.left==null && root.right==null)) return true;
         invertTree(root.right);
       return solve(root.left,root.right);
    
    }
}