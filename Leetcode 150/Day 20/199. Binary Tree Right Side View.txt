Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

 

Example 1:

Input: root = [1,2,3,null,5,null,4]

Output: [1,3,4]

Explanation:



Example 2:

Input: root = [1,2,3,4,null,null,null,5]

Output: [1,3,4,5]

Explanation:



Example 3:

Input: root = [1,null,3]

Output: [1,3]

Example 4:

Input: root = []

Output: []



solution:::



class Solution {
    class Pair
    {
        TreeNode node;
        int level;
        Pair(TreeNode node,int level)
        {
            this.node=node;
            this.level=level;
        }
    }
    public List<Integer> rightSideView(TreeNode root) {
        if(root==null) return new ArrayList<>();
      List<Integer> ans=new ArrayList<>();
      Queue<Pair> q=new ArrayDeque<>();
      q.add(new Pair(root,0));
      while(q.size()>0)
      {
        int n=q.size();
        int lvlUsed=0;
        while(n-->0)
        {
            Pair curr=q.poll();
            TreeNode temp=curr.node;
            int lvl=curr.level;
            if(lvlUsed==0)
            {
                ans.add(temp.val);
                lvlUsed++;
            }
            if(temp.right!=null) q.add(new Pair(temp.right,lvl+1));
            if(temp.left!=null) q.add(new Pair(temp.left,lvl+1));
        }
      }
      return ans;

    }
}