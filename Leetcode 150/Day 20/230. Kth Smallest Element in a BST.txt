Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.

 

Example 1:


Input: root = [3,1,4,null,2], k = 1
Output: 1
Example 2:


Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
 

Constraints:

The number of nodes in the tree is n.
1 <= k <= n <= 104
0 <= Node.val <= 104





approach1::



class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> st = new Stack<>();
        while (root != null) {
            st.push(root);
            root = root.left;
        }
        while (k != 0) {
            TreeNode n = st.pop();
            k--;
            if (k == 0)
                return n.val;
            n = n.right;
            while (n != null) {
                st.push(n);
                n = n.left;
            }
        }
        return -1;
    }
}



approach2::

class Solution {
    void solve(TreeNode root,List<Integer> list)
    {
        if(root==null) return; 
      solve(root.left,list);
      list.add(root.val);
      solve(root.right,list);
    }

    public int kthSmallest(TreeNode root, int k) {
             List<Integer> list=new ArrayList<>();
    solve(root,list);
    return list.get(k-1);
    }
}

